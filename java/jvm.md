#jvm体系总体分四大块：

- 类的加载机制
- jvm内存结构
- GC算法 垃圾回收
- GC分析 命令调优

# 类的生命周期
- 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象
- 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用
- 初始化，为类的静态变量赋予正确的初始值
- 使用，new出对象程序中使用
- 卸载，执行垃圾回收

# JDK1.8 PermGen（永久代）替换成Metaspace（元空间）
- 原本永久代存储的数据：符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap
- Metaspace（元空间）存储的是类的元数据信息（metadata）
元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。
- 替换的好处：一、字符串存在永久代中，容易出现性能问题和内存溢出。二、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低

# fullGC很频繁？
说明old区快满了

如果一次fullgc后,剩余对象不多,说明eden区设置太少,导致生命周期短进入old区。

如果一次fullgc后,old回收率不大,说明old区太小。

# 类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？
双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。(不能有重复的类，比如String类)
- 假设有一个开发者自己编写了一个名为java.lang.Object的类，想借此欺骗JVM。现在他要使用自定义ClassLoader来加载自己编写的java.lang.Object类。
- 然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在Bootstrap ClassLoader的路径下找到java.lang.Object类，并载入它
- 在实际开发中，我们可以通过自定义ClassLoader，并重写父类的loadClass方法，来打破这一机制。

# JVM的常见垃圾回收算法？
1. **标记-清楚算法**：前后线标记处所有需要回收的对象，在标记完成后统一回收有被标记的对象。
2. **复制算法**：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当一块内存用完了，将其存在另外一块上面，然后再把已使用过的内存空间一次清理掉。
3. **标记-整理算法**：标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所一端移动，然后直接清理掉端边界以外的内存。
4. **分代收集算法**：一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法。新生代都发现有大批对象死去，选用复制算法。老年代中因为对象存活率高，必须使用“标记-清理”或“标记-整理”算法来进行回收。